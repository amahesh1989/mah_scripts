
#!/usr/bin/python3

# NAME : pdr_add_osplot.py
# Version :   1.0
# AUTHOR : Mahesh Arumuga-Perumal  , mahesh.arumuga-perumal@ubs.com

import sys,os,shutil,subprocess
import socket
import requests as re
import pandas as pd
import numpy as np
import datetime
import math
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from jinja2 import Template

input_stats_file="/app/PDR/dyn/PDR/log/os_stats.txt"
input_config_file="/app/PDR/dyn/PDR/log/os_config.txt"
output_html_path="/app/PDR/dyn/PDR/log/index.html"
input_template_path="/app/PDR/dyn/PDR/log/index.html.skeleton"

shutil.copy('/app/PDR/dyn/PDR/log/index.html.skeleton','/app/PDR/dyn/PDR/log/index.html.skeleton.tmp')
input_template_path_tmp="/app/PDR/dyn/PDR/log/index.html.skeleton.tmp"

subprocess.call(["chmod","777", input_template_path_tmp])
subprocess.call(["chmod","777", input_template_path])


host=str(subprocess.check_output('hostname',shell=True).decode("utf-8").rstrip())
url='http://' + host + ':8008/cluster'
#url='http://a302-4806-9060.zur.swissbank.com:8008/cluster'
#url='http://a311-5694-6906.flur.zuerich.ubs.ch:8008/cluster'
try:
    x=re.get(url, timeout=5)
    data=x.json()
    out_str=''
    warn_cnt=0
    crit_cnt=0
    out_str+='<br><table border="1" style="border-collapse: collapse">'
    out_str+='<tr><th bgcolor=gray>Name</th><th bgcolor=gray>Hostname</th><th bgcolor=gray>IP</th><th bgcolor=gray>Role</th><th bgcolor=gray>State</th><th bgcolor=gray>Port</th><th bgcolor=gray>Lag</th></tr>'
    for i in range(len(data['members'])):
        bg=''
        name=data['members'][i]['name']
        ip=data['members'][i]['host']
        host_n=socket.getfqdn(ip)
        role=data['members'][i]['role']
        state=data['members'][i]['state']
        port=str(data['members'][i]['port'])

        if role == 'leader':
            lag='NA'
        else:
            lag=data['members'][i]['lag']
            if lag > 0:
                bg='bgcolor=#FF8C00;'
                warn_cnt+=1

        if state != 'running':
            bg='bgcolor=red'
            crit_cnt+=1

        out_str+='<tr><td ' + bg + '>' + name + '</td>'
        out_str+='<td ' + bg + '>' + host_n + '</td>'
        out_str+='<td ' + bg + '>' + ip + '</td>'
        out_str+='<td ' + bg + '>' + role + '</td>'
        out_str+='<td ' + bg + '>' + state + '</td>'
        out_str+='<td ' + bg + '>' + port + '</td>'
        out_str+='<td ' + bg + '>' + str(lag) + '</td></tr>'

    out_str+='</table>'

    if crit_cnt > 0:
        collap_color='red'
    elif warn_cnt>0:
        collap_color='orange'
    else:
        collap_color='green'
    out_str='<br><button class="collapsible ' + collap_color + '">Patroni Status</button><div class="content"> <br>' + out_str
    out_str+='</div>'
except re.exceptions.Timeout:
    out_str='<h3 style="color: red">Patroni REST API Timed out</h3>'
except re.exceptions.ConnectionError:
    out_str=''

out_str+='<script>var coll = document.getElementsByClassName("collapsible");var i;for (i = 0; i < coll.length; i++) {coll[i].addEventListener("click", function() {this.classList.toggle("active");var content = this.nextElementSibling; if (content.style.maxHeight){content.style.maxHeight = null;} else {content.style.maxHeight = content.scrollHeight + "px";}});}</script>'

if not os.path.exists(input_config_file):
    with open(input_template_path) as f:
        newText=f.read().replace('OS_CONFIG_DATA', '<h3> OS Configuration Data collection in progress. Check again after next run </h3>').replace('PATRONI_STATUS', out_str)

    with open(input_template_path_tmp, "w") as f:
        f.write(newText)
else:
    with open(input_config_file) as c:
        data=c.read().replace('\n', '')

    with open(input_template_path) as n:
        newText=n.read().replace('OS_CONFIG_DATA',data).replace('PATRONI_STATUS', out_str)

    with open(input_template_path_tmp, "w") as n:
        n.write(newText)




if not os.path.exists(input_stats_file):
    with open(input_template_path_tmp) as f:
        newText=f.read().replace('{{ fig }}', '<h3> OS Metrics collection in progress. Check again after next run </h3>')

    with open(output_html_path, "w") as f:
        f.write(newText)

    sys.exit()




cols=["TS", "CPU_USED_PERC","MEM_USED_PERC","SWAP_USED_PERC","IO_READ_PS","IO_WRITE_PS"]

try:
    df=pd.read_csv(input_stats_file,header=None,names=cols,dtype={
    'TS': 'str',
    'CPU_USED_PERC': 'float',
    'MEM_USED_PERC': 'float',
    'SWAP_USED_PERC': 'float',
    'IO_READ_PS': 'float',
    'IO_WRITE_PS': 'float'
    },on_bad_lines='skip')
except:
    df=pd.read_csv(input_stats_file,header=None,names=cols,dtype={
    'TS': 'str',
    'CPU_USED_PERC': 'float',
    'MEM_USED_PERC': 'float',
    'SWAP_USED_PERC': 'float',
    'IO_READ_PS': 'float',
    'IO_WRITE_PS': 'float'
    },error_bad_lines=False)

df['TS'] = pd.to_datetime(df['TS'], format='%Y-%m-%d %H:%M:%S', errors='coerce')
df=df.dropna()

df = df[df.TS >= (df.TS.max() - pd.Timedelta(hours=72)).floor('H')].reset_index(drop=True)
df.to_csv(input_stats_file,header=False, index=False)
df['CPU_USED_PERC']=100-df['CPU_USED_PERC']
df['IO_READ_PS']=df['IO_READ_PS']/2
df['IO_WRITE_PS']=df['IO_WRITE_PS']/2
df['TS'] = df['TS'].apply(lambda x: x - datetime.timedelta(minutes=x.minute % 5,
                             seconds=x.second))

df=df.set_index('TS').resample('5T').max().replace(0.00, np.nan).reset_index()

metrics={'col':['CPU_USED_PERC','MEM_USED_PERC','SWAP_USED_PERC'],'msg':['CPU Utilization','Memory Utilization','Swap Utilization']}

m=pd.DataFrame(metrics,index=['cpu','mem','swp'])


fig = make_subplots(rows=2, cols=2, shared_xaxes=True, horizontal_spacing = 0.05,vertical_spacing= 0.07,
                     subplot_titles=("CPU Utilization", "Memory Utilization", "Swap Utilization", "IO Utilization"))

fig.append_trace(go.Scatter(
   x=list(df.TS), y=list(df.CPU_USED_PERC),name='CPU Used %')
, row=1, col=1)

fig.append_trace(go.Scatter(
   x=list(df.TS), y=list(df.MEM_USED_PERC),name='Memory Used (commit %)')
, row=1, col=2)

fig.append_trace(go.Scatter(
   x=list(df.TS), y=list(df.SWAP_USED_PERC),name='Swap Used %')
, row=2, col=1)

fig.append_trace(go.Scatter(
    x=list(df.TS), y=list(df.IO_READ_PS),name='Read KBs per second')
, row=2, col=2)

fig.append_trace(go.Scatter(
    x=list(df.TS), y=list(df.IO_WRITE_PS),name='Write KBs per second')
, row=2, col=2)


fig.update_layout(
    xaxis=dict(
        rangeselector=dict(
            buttons=list([
                dict(count=15,
                     label="15m",
                     step="minute",
                     stepmode="backward"),
                dict(count=1,
                     label="1h",
                     step="hour",
                     stepmode="backward"),
                dict(count=6,
                     label="6h",
                     step="hour",
                     stepmode="backward"),
                dict(count=12,
                     label="12h",
                     step="hour",
                     stepmode="backward"),
                dict(count=1,
                     label="1d",
                     step="day",
                     stepmode="backward"),
                dict(count=2,
                     label="2d",
                     step="day",
                     stepmode="backward"),
                ])
        ),
        rangeslider=dict(
            visible=False
        ),
        type="date"
    )
)

cpu_range=mem_range=swp_range=100

if df['CPU_USED_PERC'].max() > 100 : cpu_range=int(math.ceil(df['CPU_USED_PERC'].max() / 50.0)) * 50
if df['MEM_USED_PERC'].max() > 100 : mem_range=int(math.ceil(df['MEM_USED_PERC'].max() / 50.0)) * 50
if df['SWAP_USED_PERC'].max() > 100 : swp_range=int(math.ceil(df['SWAP_USED_PERC'].max() / 50.0)) * 50

fig.update_layout(yaxis_range=[0,cpu_range])
fig.update_layout(yaxis2_range=[0,mem_range])
fig.update_layout(yaxis3_range=[0,swp_range])

# fig.update_layout(yaxis_range=[0,100])
# fig.update_layout(yaxis2_range=[0,100])
# fig.update_layout(yaxis3_range=[0,100])

fig.update_xaxes(matches='x')

#fig.update_layout(height=1000, width=1900, title_text="OS Metrics")
fig.update_layout(height=1000, width=1900,xaxis_showticklabels=True, xaxis2_showticklabels=True)

#with open(output_html_path, 'a') as f:
#    f.write(fig.to_html(full_html=False, include_plotlyjs='cdn'))


plotly_jinja_data = {"fig":fig.to_html(full_html=False)}
#consider also defining the include_plotlyjs parameter to point to an external Plotly.js as described above

with open(output_html_path, "w", encoding="utf-8") as output_file:
    with open(input_template_path_tmp) as template_file:
        j2_template = Template(template_file.read())
        output_file.write(j2_template.render(plotly_jinja_data))
